var documenterSearchIndex = {"docs":
[{"location":"bitstrings/#Contents","page":"Working with bit strings","title":"Contents","text":"","category":"section"},{"location":"bitstrings/","page":"Working with bit strings","title":"Working with bit strings","text":"Pages = [\"bitstrings.md\"]\nDepth = 5","category":"page"},{"location":"bitstrings/","page":"Working with bit strings","title":"Working with bit strings","text":"CurrentModule = BitsX","category":"page"},{"location":"bitstrings/#Creating-and-parsing-bit-strings","page":"Working with bit strings","title":"Creating and parsing bit strings","text":"","category":"section"},{"location":"bitstrings/","page":"Working with bit strings","title":"Working with bit strings","text":"parse_bin converts a bit string to a bitstype value, such as UInt64. parse_bin is similar to Base.parse, but is faster, and more versatile.","category":"page"},{"location":"bitstrings/","page":"Working with bit strings","title":"Working with bit strings","text":"bstring creates a bit string from the bits in a bitstype value, or another object representing an array of bits. bstring is similar to Base.bitstring in function and performance, but is more versatile.","category":"page"},{"location":"bitstrings/#Functions","page":"Working with bit strings","title":"Functions","text":"","category":"section"},{"location":"bitstrings/#parse_bin","page":"Working with bit strings","title":"parse_bin","text":"","category":"section"},{"location":"bitstrings/","page":"Working with bit strings","title":"Working with bit strings","text":"BitsX.ParseBin.parse_bin","category":"page"},{"location":"bitstrings/#BitsX.ParseBin.parse_bin","page":"Working with bit strings","title":"BitsX.ParseBin.parse_bin","text":"parse_bin([::Type{T}], s::Union{AbstractString, AbstractVector{UInt8}}; filter=false, rev=false)\n\nConvert an integer coded as a binary string (characters '1' and '0') to an unsigned integer.\n\nThe return type is T. If the first argument is omitted, then the return type is the narrowest suitable unsigned integer type.\n\nThe type T is typically a bits type UInt8, UInt16, Float64, etc., where the number of bits is a factor of 8. The largest unsigned integer type that is pre-generated from BitIntegers.jl is UInt1024. If T is omitted, a type that has not been pre-generated will be created.\n\nLeading zeros are included in the calculation of the width of the resulting integer.\n\nIf filter is true, then characters other than '1' and '0' are ignored rather than raising an error. In this way, formatting, such as spaces, may be included in the input string.\n\nIf rev is true then the string is parsed from right to left rather than left to right. This incurrs no performance penalty.\n\nwarning: Ascii only\nNon-ascii characters in the bitstring, even with filter=true will probably result in an error or incorrect results.\n\nExamples\n\njulia> parse_bin(UInt8, \"10001111\") |> bitstring\n\"10001111\"\n\njulia> parse_bin(UInt8, \"1000 1111\")\nERROR: BoundsError: attempt to access 8-element Vector{UInt8} at index [9]\n\njulia> parse_bin(UInt8, \"10 00 11 11\"; filter=true) |> bitstring\n\"10001111\"\n\njulia> parse_bin(UInt8, \"10001111\"; rev=true) |> bitstring\n\"11110001\"\n\njulia> parse_bin(Bool, \"1\")\ntrue\n\nVarious input types are supported.\n\njulia> s = \"0001111100000100\";\n\njulia> parse_bin.(UInt16, (s, codeunits(s), collect(codeunits(s))))\n(0x1f04, 0x1f04, 0x1f04)\n\nThe type parameter need not be a bitstype.\n\njulia> x = parse_bin(Signed, s); (x, typeof(x))\n(7940, Int16)\n\njulia> x = parse_bin(Unsigned, s); (x, typeof(x))\n(0x1f04, UInt16)\n\njulia> x = parse_bin(Integer, s); (x, typeof(x))\n(0x1f04, UInt16)\n\njulia> x = parse_bin(BigInt, s); (x, typeof(x))\n(7940, BigInt)\n\nwarning: Warning\nIf characters other than '0' and '1' are present and filter=true, then the minimum bit width may be computed incorrectly. However if T is a bitstype, then no minimum bit width need be computed.\n\njulia> parse_bin(\"1\"^8; filter=true)\n0xff\n\njulia> parse_bin(\"1\"^8 * \" \"^8; filter=true)\n0x00ff\n\njulia> parse_bin(UInt8, \"1\"^8 * \" \"^8; filter=true)\n0xff\n\nExtended help\n\nComparison with Base.parse\n\nparse_bin is roughly 5 to 10 faster.\nparse_bin can optionally ignore non-coding characters (formatting, for example) in the string\nparse_bin can accept AbstractVector{UInt8} as input.\nparse_bin can parse the characters in reverse order (at no performance cost).\n\nPerformance\n\nUsually parse_bin is faster than Base.parse. The factor varies from about 5 to 10. However, for bit widths larger than about 650, parse_bin first parses the string as a BigInt using Base.parse and then converts to the appropriate fixed-wdith unsigned integer type.\n\nparse_bin is often much faster if T is supplied because otherwise the return type cannot be inferred.\n\n\n\n\n\n","category":"function"},{"location":"bitstrings/#bstring","page":"Working with bit strings","title":"bstring","text":"","category":"section"},{"location":"bitstrings/","page":"Working with bit strings","title":"Working with bit strings","text":"BitsX.BStrings.bstring","category":"page"},{"location":"bitstrings/#BitsX.BStrings.bstring","page":"Working with bit strings","title":"BitsX.BStrings.bstring","text":"bstring(x::T; len::Union{Int, Nothing}, rev::Bool=true, sep::Int=0, pad::Bool=false)\n\nReturn a string giving the literal bit representation of x of a primitive type.\n\nIf rev is true (the default), then the string is reversed with respect to Base.bitstring.\n\nIf len is an Int, then the string will have length len.  If len is greater than the bit-width of x then the string will be padded with '0'. If len is smaller than the bit-width of x, then upper bits will be truncated.\n\nIf pad is true, then the behavior of len is modified: At least all bits other than leading zeros are written.  By setting len large enough you can write leading zeros as well.\n\nIf sep is greater than zero, a space is inserted every sep bits.\n\nExamples\n\nAll bits are written by default. Most significant bit is leftmost.\n\njulia> bstring(UInt16(11))\n\"1101000000000000\"\n\nIf rev is false, the most significant bit is rightmost.\n\njulia> bstring(UInt16(11); rev=false)\n\"0000000000001011\"\n\nIf pad is true, leading zeros are omitted.\n\njulia> bstring(UInt16(11); pad=true)\n\"1101\"\n\njulia> bstring(UInt16(11); pad=true, rev=false)\n\"1011\"\n\nlen is the number of bits to write.\n\njulia> bstring(UInt16(11); len=8)\n\"11010000\"\n\njulia> bstring(UInt16(11); len=8, rev=false)\n\"00001011\"\n\njulia> bstring(UInt16(11); len=3)\n\"110\"\n\nIf len is passed and pad is true, the most significant bit will always be written.\n\njulia> bstring(UInt16(11); len=3, pad=true)\n\"1101\"\n\njulia> bstring(UInt16(11); len=8, pad=true)\n\"11010000\"\n\nA space is inserted every sep bits.\n\njulia> x = 0xf0ff00aa00; bstring(x; sep=8)\n\"00000000 01010101 00000000 11111111 00001111 00000000 00000000 00000000\"\n\n\n\n\n\n","category":"function"},{"location":"bitstrings/#bstringview","page":"Working with bit strings","title":"bstringview","text":"","category":"section"},{"location":"bitstrings/","page":"Working with bit strings","title":"Working with bit strings","text":"BitsX.BStringViews.bstringview","category":"page"},{"location":"bitstrings/#BitsX.BStringViews.bstringview","page":"Working with bit strings","title":"BitsX.BStringViews.bstringview","text":"bstringview(v, [n])\n\nReturn an AbstractString view of v that represent a sequence of bits.\n\nv may be of any type such that BitsBase.to_binary_char returns a character (i.e. does not throw an error) for each element of v as determined by Bits.bit.\n\nExamples\n\njulia> bstringview([1,0,1,1])\n\"1011\"\n\njulia> bstringview(UInt8(1 << 4 - 1))\n\"11110000\"\n\njulia> bstringview(\"110\") # `bit` is implemented for binary strings.\n\"110\"\n\njulia> bsv = bstringview([true, false, true, false])\n\"1010\"\n\njulia> bsv[end]\n'0': ASCII/Unicode U+0030 (category Nd: Number, decimal digit)\n\njulia> bsv[end] = '1'\n'1': ASCII/Unicode U+0031 (category Nd: Number, decimal digit)\n\njulia> bsv\n\"1011\"\n\njulia> bsv[end] = false\nfalse\n\n\nIf n is omitted, then the length of the string is the number of bits in v. For example, for v = UInt64(1), the length of the string is 64. For v::AbstractArray, the number of bits is length(v).\n\nIf n is zero, then the length of the string is the minimum number of bits needed to represent v. For example\n\nExamples\n\njulia> length(bstringview(UInt64(7)))\n64\n\njulia> length(bstringview(UInt64(7), 5))\n5\n\njulia> length(bstringview(UInt64(7), 0))\n3\n\njulia> bstringview(UInt64(7), 0)\n\"111\"\n\njulia> bstringview(UInt16(7))\n\"1110000000000000\"\n\nString(bstringview(v)) converts v to a `String.\n\njulia> v = bstringview(UInt64(7), 0); vs = String(v); (v, vs)\n(\"111\", \"111\")\n\njulia> typeof.((v, vs))\n(BStringView{UInt64}, String)\n\n\n\n\n\n","category":"function"},{"location":"bitstrings/#normalize_bitstring","page":"Working with bit strings","title":"normalize_bitstring","text":"","category":"section"},{"location":"bitstrings/","page":"Working with bit strings","title":"Working with bit strings","text":"BitsX.Bits.normalize_bitstring","category":"page"},{"location":"bitstrings/#BitsX.Bits.normalize_bitstring","page":"Working with bit strings","title":"BitsX.Bits.normalize_bitstring","text":"normalize_bitstring(str::AbstractString)\n\nRemove all characters (more precisely, code points) from str that are not one of '0' and '1', if such characters exist. Otherwise, return str unchanged.\n\n\n\n\n\n","category":"function"},{"location":"bitstrings/#randbitstring","page":"Working with bit strings","title":"randbitstring","text":"","category":"section"},{"location":"bitstrings/","page":"Working with bit strings","title":"Working with bit strings","text":"BitsX.Bits.randbitstring","category":"page"},{"location":"bitstrings/#BitsX.Bits.randbitstring","page":"Working with bit strings","title":"BitsX.Bits.randbitstring","text":"randbitstring([rng = default_rng()], nbits::Integer, [dims])\n\nReturn a random string of '1's and '0's of length nbits.\n\nThe distribution is uniform over all such strings. If dims is given return an Array of random bitstrings with dimensions dims.\n\nExamples\n\njulia> import Random; rng = Random.seed!(10);\n\njulia> randbitstring(rng, 10)\n\"1011110111\"\n\nSee also randbitstring!.\n\n\n\n\n\n","category":"function"},{"location":"bitstrings/#randbitstring!","page":"Working with bit strings","title":"randbitstring!","text":"","category":"section"},{"location":"bitstrings/","page":"Working with bit strings","title":"Working with bit strings","text":"BitsX.Bits.randbitstring!","category":"page"},{"location":"bitstrings/#BitsX.Bits.randbitstring!","page":"Working with bit strings","title":"BitsX.Bits.randbitstring!","text":"randbitstring!([rng = default_rng()], a::AbstractArray, nbits::Integer)\n\nFill array a with random bitstrings.\n\n\n\n\n\n","category":"function"},{"location":"bitstrings/#is_bitstring","page":"Working with bit strings","title":"is_bitstring","text":"","category":"section"},{"location":"bitstrings/","page":"Working with bit strings","title":"Working with bit strings","text":"BitsX.BitsBase.is_bitstring","category":"page"},{"location":"bitstrings/#BitsX.BitsBase.is_bitstring","page":"Working with bit strings","title":"BitsX.BitsBase.is_bitstring","text":"is_bitstring(bit_str::Union{AbstractString, AbstractVector{UInt8}})\n\nReturn true if all characters in bit_str are either '0' or '1', otherwise false.\n\nExamples\n\njulia> is_bitstring(\"11001100\")\ntrue\n\njulia> is_bitstring(\"1100 1100\")\nfalse\n\n\n\n\n\n","category":"function"},{"location":"bitstrings/#check_bitstring","page":"Working with bit strings","title":"check_bitstring","text":"","category":"section"},{"location":"bitstrings/","page":"Working with bit strings","title":"Working with bit strings","text":"BitsX.BitsBase.check_bitstring","category":"page"},{"location":"bitstrings/#BitsX.BitsBase.check_bitstring","page":"Working with bit strings","title":"BitsX.BitsBase.check_bitstring","text":"check_bitstring(bit_str::Union{AbstractString, AbstractVector{UInt8}})\n\nThrow an ArgumentError unless  all characters in bit_str are either '0' or '1'. Otherwise return nothing.\n\nExamples\n\njulia> check_bitstring(\"11001100\")\ntrue\n\njulia> check_bitstring(\"1010010b\")\nERROR: ArgumentError: Argument is not a bit string\n\n\n\n\n\n","category":"function"},{"location":"misc/#Everything-else","page":"Everything else","title":"Everything else","text":"","category":"section"},{"location":"misc/","page":"Everything else","title":"Everything else","text":"Docstrings for functions and object that are not yet organized in these docs are presented below.","category":"page"},{"location":"misc/","page":"Everything else","title":"Everything else","text":"CurrentModule = BitsX","category":"page"},{"location":"misc/","page":"Everything else","title":"Everything else","text":"Modules = [BitsX.BitArrayViews]","category":"page"},{"location":"misc/#BitsX.BitArrayViews.BitArrayView","page":"Everything else","title":"BitsX.BitArrayViews.BitArrayView","text":"BitArrayView{V, N, T} <: AbstractArray{V, N}\n\nView an object of type T as an AbstractArray{V, N} where V is the eltype and N the number of dimensions.\n\n\n\n\n\n","category":"type"},{"location":"misc/#BitsX.BitArrayViews.bitmatview-Tuple","page":"Everything else","title":"BitsX.BitArrayViews.bitmatview","text":"bitmatview([::Type{V} = Bool], str, [ncols::Integer = isqrt(bitlength(str))]; kwargs...)\n\nReturn a view of the bitstring str as a matrix, a BitMatrixView{V, T} <: AbstractMatrix{T}.\n\nIf ncols is supplied, the number of rows will be the largest compatible with the length of str. On construction str will be validated as a bitstring. If the keyword arg check=false is passed, then no such check is made.\n\n\n\n\n\n","category":"method"},{"location":"misc/#BitsX.BitArrayViews.bitvecview-Union{Tuple{AbstractString}, Tuple{ET}, Tuple{AbstractString, Val{ET}}} where ET","page":"Everything else","title":"BitsX.BitArrayViews.bitvecview","text":"bitvecview([::Type{T} = Bool], str::AbstractString; check=true)\n\nReturn a view of the bitstring str as an AbstractVector{T}.\n\nNo data is copied. If check is true, then str is validated upon construction. A valid str must consist of only '0' and '1'. Passing false for check with invalid str will likely give incorrect results, silently.\n\nIf you instead convert str to Vector{Bool}, construction may take longer, but accessing will be faster. So bitvecview might be more useful if you want to do only a few operations.\n\nTo convert str to a Vector{T} call collect or copy on the returned view of str. Likewise Tuple and BitVector can be used to convert to the corresponding types.\n\n\n\n\n\n","category":"method"},{"location":"misc/#BitsX.BitArrayViews.is_little_endian-Union{Tuple{BitArrayView{<:Any, <:Any, <:Any, ET}}, Tuple{ET}} where ET","page":"Everything else","title":"BitsX.BitArrayViews.is_little_endian","text":"is_little_endian(bv::BitArrayView)\n\nReturn true if the bits in the representation bv of parent(bv), where the latter is a bitsttype, have the least significant bit at index 1.\n\nFor other wrapped types, such as String, return true if the indexing is not reversed.\n\n\n\n\n\n","category":"method"},{"location":"misc/","page":"Everything else","title":"Everything else","text":"Modules = [BitsX.StaticBitVectors]","category":"page"},{"location":"misc/","page":"Everything else","title":"Everything else","text":"Modules = [BitsX.BitArraysX]","category":"page"},{"location":"misc/#BitsX.BitArraysX._BitArraysX.Chunks","page":"Everything else","title":"BitsX.BitArraysX._BitArraysX.Chunks","text":"Chunks{T<:Unsigned}\n\nChunks is a wrapper used to pass data to constructors of AbstractBitArray that is intended to be used directly as \"chunks\". If an un-wrapped array is passed it is assumed to be interpreted as an array of Bools.\n\nPeople have discussed constructing Base.BitArray by passing chunks. Something like Chunk would be useful there, to distinguish clearly from existing methods.\n\n\n\n\n\n","category":"type"},{"location":"misc/","page":"Everything else","title":"Everything else","text":"Modules = [BitsX.BitIntegersX]","category":"page"},{"location":"misc/#BitsX.BitIntegersX.get_one_bit_masks-Tuple{Any}","page":"Everything else","title":"BitsX.BitIntegersX.get_one_bit_masks","text":"get_one_bit_masks(::Type{uint_type})\n\nReturn an array of all single bit (powers of two) masks for uint_type.\n\nMasks are generated when BitsX is compiled. If masks are not available for a type, then the sentinel nothing is returned. This signifies that a routine that does not require masks should be used.\n\n\n\n\n\n","category":"method"},{"location":"misc/#BitsX.BitIntegersX.min_uint_bit_width-Tuple{Integer}","page":"Everything else","title":"BitsX.BitIntegersX.min_uint_bit_width","text":"min_uint_bit_width(nbits::Integer)\n\nReturn the minimum width in bits of the unsigned integer needed to represent nbits bits. The widths are restricted to multiples of eight.\n\n\n\n\n\n","category":"method"},{"location":"misc/#BitsX.BitIntegersX.min_uint_byte_width-Tuple{Int64}","page":"Everything else","title":"BitsX.BitIntegersX.min_uint_byte_width","text":"min_uint_byte_width(n_bits::Integer)\n\nReturn the minimum width in bytes of the unsigned integer needed to represent nbits bits. The widths are restricted to multiples of eight.\n\n\n\n\n\n","category":"method"},{"location":"misc/#BitsX.BitIntegersX.min_uint_type-Tuple{Int64}","page":"Everything else","title":"BitsX.BitIntegersX.min_uint_type","text":"min_uint_type(nbits::Integer)\n\nReturn the smallest unsigned integer type large enough to store nbits bits. The number of bits in the type returned is a multiple of 8.\n\n\n\n\n\n","category":"method"},{"location":"misc/#BitsX.BitIntegersX.uint_type-Tuple{Int64}","page":"Everything else","title":"BitsX.BitIntegersX.uint_type","text":"uint_type(n_bits::Integer)\n\nReturn an n_bits-bit unsigned integers type UIntn_bits. n_bits must be a positive mulitple of 8.\n\nIf UIntn does not exist, construct UIntn and Intn.\n\n\n\n\n\n","category":"method"},{"location":"misc/#BitsX.BitIntegersX.uint_type_bytes-Tuple{Integer}","page":"Everything else","title":"BitsX.BitIntegersX.uint_type_bytes","text":"uint_type_bytes(n_bytes::Integer)\n\nReturn an n_bytes-byte unsigned integer type.\n\nThe returned type is named UIntX where X = 8 * n_bytes. If UIntX does not exist construct UIntX and IntX.\n\n\n\n\n\n","category":"method"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"CurrentModule = BitsX.BitsBase","category":"page"},{"location":"bitsbase/#Contents","page":"BitsBase","title":"Contents","text":"","category":"section"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"Pages = [\"bitsbase.md\"]\nDepth = 5","category":"page"},{"location":"bitsbase/#BitsBase","page":"BitsBase","title":"BitsBase","text":"","category":"section"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"BitsBase","category":"page"},{"location":"bitsbase/#BitsX.BitsBase","page":"BitsBase","title":"BitsX.BitsBase","text":"BitsBase\n\nThis submodule implements some abstractions for working with bits that are used by other submodules.\n\nThe conceit is that it should be possible to write (performant) function methods for working with bits that have minimal dependence on the representation of the bits. Bits can be represented by unsigned integers, arrays of unsigned integers, Strings, and lazy views of each of these as a different bit representation. We want to write methods that don't depend on which representation we use.\n\nAnalogs to Base.collect, size, sizeof, getindex, eachindex, axes are  BitsX.Bits.bitcollect, bitsize, bitsizeof, bit, biteachindex, and bitaxes.\n\nAn example of a function built on these abstractions is bitcollect, which has this definition\n\nfunction bitcollect(obj)\n    array = Array{Bool}(undef, bitsize(obj))\n    # Assume LinearIndices. Probably not always correct\n    for (i, ind) in enumerate(biteachindex(obj))\n        array[i] = bit(obj, ind)\n    end\n    array\nend\n\nNote that bitcollect depends on bitsize, bit, and biteachindex. The latter depends on bitaxes1, which depends on bitaxes.\n\nExamples\n\nHere are some concrete examples.\n\njulia> s = \"10101010\"; x = parse(UInt8, s; base=2); v = Bool[1,0,1,0,1,0,1,0];\n\njulia> bitlength.((x, v, s, codeunits(s)))\n(8, 8, 8, 8)\n\nPerformance\n\nA goal is that there be little or no performance penalty for using this interface.\n\nFor example, because the bitstrings contain only ASCII characters, bitlength(::String) does not traverse the entire string\n\njulia> s = \"1\"^1000;\n\njulia> @btime length($s)\n  401.550 ns (0 allocations: 0 bytes)\n1000\n\njulia> @btime bitlength($s)\n  1.763 ns (0 allocations: 0 bytes)\n1000\n\n\n\n\n\n","category":"module"},{"location":"bitsbase/#binzero","page":"BitsBase","title":"binzero","text":"","category":"section"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"binzero","category":"page"},{"location":"bitsbase/#BitsX.BitsBase.binzero","page":"BitsBase","title":"BitsX.BitsBase.binzero","text":"binzero(x::T)\n\nThe value of type T representing bit value zero.\n\nIf T <: Integer, or a matrix thereof, return zero(::T).  If T is other AbstractArray, AbstractString, AbstractFloat, Complex, throw a MethodError.\n\nThe fallback method returns zero(x).\n\n\n\n\n\nbinzero(x)\n\nThe value of type T representing bit value zero.\n\nExamples\n\njulia> binzero.((Char, '-', Int, UInt8, 42))\n('0', '0', 0, 0x00, 0)\n\n\n\n\n\n","category":"function"},{"location":"bitsbase/#binone","page":"BitsBase","title":"binone","text":"","category":"section"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"binone","category":"page"},{"location":"bitsbase/#BitsX.BitsBase.binone","page":"BitsBase","title":"BitsX.BitsBase.binone","text":"binone(x::T)\n\nThe value of type T representing bit value one.\n\nExamples\n\njulia> binone.((Char, '-', Int, UInt8, 42))\n('1', '1', 1, 0x01, 1)\n\n\n\n\n\n","category":"function"},{"location":"bitsbase/#isbinzero","page":"BitsBase","title":"isbinzero","text":"","category":"section"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"isbinzero","category":"page"},{"location":"bitsbase/#BitsX.BitsBase.isbinzero","page":"BitsBase","title":"BitsX.BitsBase.isbinzero","text":"isbinzero(x)\n\nReturn true if x represents bit value zero.\n\nSee also binzero.\n\n\n\n\n\n","category":"function"},{"location":"bitsbase/#isbinzero-2","page":"BitsBase","title":"isbinzero","text":"","category":"section"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"isbinone","category":"page"},{"location":"bitsbase/#BitsX.BitsBase.isbinone","page":"BitsBase","title":"BitsX.BitsBase.isbinone","text":"isbinone(x)\n\nReturn true if x represents bit value one.\n\nSee also binone.\n\n\n\n\n\n","category":"function"},{"location":"bitsbase/#isbin","page":"BitsBase","title":"isbin","text":"","category":"section"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"isbin","category":"page"},{"location":"bitsbase/#BitsX.BitsBase.isbin","page":"BitsBase","title":"BitsX.BitsBase.isbin","text":"isbin(b)::Bool\n\nReturn true is b represents a binary digit.\n\nThis is of course subjective in general. But this package has rules for what values of various types can be interpreted as Bools.\n\nExamples\n\njulia> isbin.((true, false, 1, 0, '1', '0', 42, 'c'))\n(true, true, true, true, true, true, false, false)\n\njulia> isbin(\"1\")\nERROR: MethodError: no method matching binzero(::String)\n\n\n\n\n\n","category":"function"},{"location":"bitsbase/#is_zero_char","page":"BitsBase","title":"is_zero_char","text":"","category":"section"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"is_zero_char","category":"page"},{"location":"bitsbase/#BitsX.BitsBase.is_zero_char","page":"BitsBase","title":"BitsX.BitsBase.is_zero_char","text":"is_zero_char(x)\n\nReturn true if x is equal to '0' or its ASCII code.\n\nExamples\n\njulia> is_zero_char.(('0', '1', 'c', UInt8('0'), UInt8('1'), UInt8('c')))\n(true, false, false, true, false, false)\n\n\n\n\n\n","category":"function"},{"location":"bitsbase/#is_one_char","page":"BitsBase","title":"is_one_char","text":"","category":"section"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"is_one_char","category":"page"},{"location":"bitsbase/#BitsX.BitsBase.is_one_char","page":"BitsBase","title":"BitsX.BitsBase.is_one_char","text":"is_one_char(x)\n\nReturn true if x is equal to '1' or its ASCII code.\n\nExamples\n\njulia> is_one_char.(('0', '1', 'c', UInt8('0'), UInt8('1'), UInt8('c')))\n(false, true, false, false, true, false)\n\njulia> is_one_char.((Int('1'), 42))\n(true, false)\n\n\n\n\n\n","category":"function"},{"location":"bitsbase/#is_binary_char","page":"BitsBase","title":"is_binary_char","text":"","category":"section"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"is_binary_char","category":"page"},{"location":"bitsbase/#BitsX.BitsBase.is_binary_char","page":"BitsBase","title":"BitsX.BitsBase.is_binary_char","text":"is_binary_char(x)\n\nReturn true if x is equal to either '0' or '1' or their ASCII codes.\n\nExamples\n\njulia> is_binary_char.(('1', Int('1'), '0', 'a', 100))\n(true, true, true, false, false)\n\n\n\n\n\n","category":"function"},{"location":"bitsbase/#to_binary_char","page":"BitsBase","title":"to_binary_char","text":"","category":"section"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"to_binary_char","category":"page"},{"location":"bitsbase/#BitsX.BitsBase.to_binary_char","page":"BitsBase","title":"BitsX.BitsBase.to_binary_char","text":"to_binary_char(x::T)::Char\n\nConvert x to the Char '0' or '1'. x must be equal to either binzero(T) or binone(T).\n\nExamples\n\njulia> to_binary_char.((1, '1', true, 0x01, 0, '0', false, 0x00))\n('1', '1', '1', '1', '0', '0', '0', '0')\n\n\n\n\n\n","category":"function"},{"location":"bitsbase/#to_binary_char_code","page":"BitsBase","title":"to_binary_char_code","text":"","category":"section"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"to_binary_char_code","category":"page"},{"location":"bitsbase/#BitsX.BitsBase.to_binary_char_code","page":"BitsBase","title":"BitsX.BitsBase.to_binary_char_code","text":"to_binary_char_code(x::T)::UInt8\n\nConvert x to the ASCII code for character '0' or '1'.  One of isbinzero(x) or isbinone(x) must return true.\n\nisbinzero and isbinone fall back to iszero and isone where this makes sense.\n\nT must implement iszero (or zero) and isone (or one). Alternatively, you can implement isbinzero (or binzero) and isbinone (or binone)\n\nExamples\n\njulia> to_binary_char_code.((1, '1', true, 0x01, 0, '0', false, 0x00))\n(0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30)\n\njulia> to_binary_char_code(42)\nERROR: DomainError with 42:\nMust be zero or one value of type Int64.\n\nSee also binzero, binone.\n\n\n\n\n\n","category":"function"},{"location":"bitsbase/#from_binary_char","page":"BitsBase","title":"from_binary_char","text":"","category":"section"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"from_binary_char","category":"page"},{"location":"bitsbase/#BitsX.BitsBase.from_binary_char","page":"BitsBase","title":"BitsX.BitsBase.from_binary_char","text":"from_binary_char([::Type{T} = Bool], x)\n\nConvert the characters '0' and '1' (or UInt8('0') and UInt8('1')) to binzero(T) and binone(T).\n\nExamples\n\njulia> from_binary_char.(Bool, ('1', UInt8('1'), '0', UInt8('0')))\n(true, true, false, false)\n\njulia> from_binary_char('c')\nERROR: DomainError with 99:\n\n\n\n\n\n","category":"function"},{"location":"bitsbase/#bitconvert","page":"BitsBase","title":"bitconvert","text":"","category":"section"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"bitconvert","category":"page"},{"location":"bitsbase/#BitsX.BitsBase.bitconvert","page":"BitsBase","title":"BitsX.BitsBase.bitconvert","text":"bitconvert([T=Bool], b)::T\n\nConvert the representation of a bit b to the representation of a bit of type T.\n\nExamples\n\njulia> bitconvert.((true, 1, UInt64(1), '1'))\n(true, true, true, true)\n\njulia> bitconvert(3)\nERROR: ArgumentError: Value 3 cannot be interpreted as a bit value of type Bool\n\njulia> bitconvert.(UInt8, ('0', 0, UInt64(0)))\n(0x00, 0x00, 0x00)\n\n\n\n\n\n","category":"function"},{"location":"bitsbase/#min_bits","page":"BitsBase","title":"min_bits","text":"","category":"section"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"min_bits","category":"page"},{"location":"bitsbase/#BitsX.BitsBase.min_bits","page":"BitsBase","title":"BitsX.BitsBase.min_bits","text":"min_bits(n::Integer)\nmin_bits(bit_str::AbstractString)\nmin_bits(v)\n\nReturn the required number of bits in the binary representation of n (or bit_str, or iterable v).\n\nThe returned value is the position of the leftmost bit equal to 1, counting from the right. Equivalently, the value is the length of the bit_str discounting leading zeros.\n\nExamples\n\njulia> min_bits(2^10)\n11\n\njulia> min_bits(\"1\"^10)\n10\n\njulia> min_bits([0,1,0])\n2\n\n\n\n\n\n","category":"function"},{"location":"bitsbase/#min_dits","page":"BitsBase","title":"min_dits","text":"","category":"section"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"min_dits","category":"page"},{"location":"bitsbase/#BitsX.BitsBase.min_dits","page":"BitsBase","title":"BitsX.BitsBase.min_dits","text":"min_dits(v)\n\nReturn the minimum number of \"dits\" needed to express v.\n\nThe first element not representing zero counting from the left determines the return value. Input is not validated.\n\nExamples\n\njulia> min_dits(\"03Q\")\n2\n\njulia> min_dits([0, 3, 17])\n2\n\n\n\n\n\n","category":"function"},{"location":"bitsbase/#bitaxes","page":"BitsBase","title":"bitaxes","text":"","category":"section"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"bitaxes","category":"page"},{"location":"bitsbase/#BitsX.BitsBase.bitaxes","page":"BitsBase","title":"BitsX.BitsBase.bitaxes","text":"bitaxes(B)\n\nReturn the valid range of indices for array B when interpreted as an array of bits.\n\n\n\n\n\n","category":"function"},{"location":"bitsbase/#biteachindex","page":"BitsBase","title":"biteachindex","text":"","category":"section"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"biteachindex","category":"page"},{"location":"bitsbase/#BitsX.BitsBase.biteachindex","page":"BitsBase","title":"BitsX.BitsBase.biteachindex","text":"biteachindex(A)\n\nCreate an iterable object for visiting each index of B when interpreted as an array of bits.\n\n\n\n\n\n","category":"function"},{"location":"bitsbase/#bitlastindex","page":"BitsBase","title":"bitlastindex","text":"","category":"section"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"bitlastindex","category":"page"},{"location":"bitsbase/#BitsX.BitsBase.bitlastindex","page":"BitsBase","title":"BitsX.BitsBase.bitlastindex","text":"bitlastindex(A)\n\nReturn the last index of collection A when interpreted as an array of bits.\n\n\n\n\n\n","category":"function"},{"location":"bitsbase/#bitsizeof","page":"BitsBase","title":"bitsizeof","text":"","category":"section"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"bitsizeof","category":"page"},{"location":"bitsbase/#BitsX.BitsBase.bitsizeof","page":"BitsBase","title":"BitsX.BitsBase.bitsizeof","text":"bitsizeof(::Type{T})\n\nReturn the number of (usefully) indexable bits in an instance of type T. Here \"indexable\" means via bit(x::T, i).\n\nFor some types, such as Integers, bit(x::T, i) returns 0 for i greater than bitsizeof(T).\n\nIf the number of indexable bits in an instance of type T cannot be computed from the type alone, then an error is thrown.\n\nExamples\n\njulia> bitsizeof.((UInt8, UInt64, NTuple{5, Int}, StaticBitVectorView{Int64}))\n(8, 64, 5, 64)\n\njulia> bitsizeof(String)\nERROR: MethodError: no method matching bitsizeof(::Type{String})\n\njulia> bitsizeof(BigInt)\nERROR: MethodError: no method matching bitsizeof(::Type{BigInt})\n\n\n\n\n\n","category":"function"},{"location":"bitsbase/#bitsize","page":"BitsBase","title":"bitsize","text":"","category":"section"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"bitsize","category":"page"},{"location":"bitsbase/#BitsX.BitsBase.bitsize","page":"BitsBase","title":"BitsX.BitsBase.bitsize","text":"bitsize(B)\n\nReturn a tuple containing the dimensions of B, where B is interpreted as an array of bits.\n\nExamples\n\njulia> bitsize(42)\n(64,)\n\njulia> bitsize(UInt16(42))\n(16,)\n\njulia> bitsize(\"1011\")\n(4,)\n\njulia> bitsize(Bool[1, 0])\n(2,)\n\njulia> bitsize(BitArray(undef, (3, 4)))\n(3, 4)\n\njulia> bitsize(bstringview(42))\n(64,)\n\n\n\n\n\n","category":"function"},{"location":"bitsbase/#bitlength","page":"BitsBase","title":"bitlength","text":"","category":"section"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"bitlength","category":"page"},{"location":"bitsbase/#BitsX.BitsBase.bitlength","page":"BitsBase","title":"BitsX.BitsBase.bitlength","text":"bitlength(x::T)\n\nReturn the number of bits in the instance x of type T. This is the number of bits that can be indexed via bit. If x is an isbitstype type, then this is the same as bitsizeof(T).\n\nIn contrast, if x is of type BigInt or BigFloat the number of bits is not encoded in the type, and in fact may vary from instance to instance.\n\n\n\n\n\nbitlength(str::AbstractString)\n\nThe number of characters in str, which is assumed to contain only '0' and '1'. If str contains other characters, the returned value will be incorrect.\n\n\n\n\n\n","category":"function"},{"location":"bitsbase/#count_bits","page":"BitsBase","title":"count_bits","text":"","category":"section"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"count_bits","category":"page"},{"location":"bitsbase/#BitsX.BitsBase.count_bits","page":"BitsBase","title":"BitsX.BitsBase.count_bits","text":"count_bits(s::AbstractString)\ncount_bits(v::AbstractVector{UInt8})\n\nReturn the number of characters (or bytes) that are '1' or '0', (0x30 or 0x31).\n\nIt is assumed that s is an ASCII string. count_bits may be useul if the string includes formatting characters, for example spaces.\n\n\n\n\n\n","category":"function"},{"location":"bitsbase/#bit","page":"BitsBase","title":"bit","text":"","category":"section"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"bit","category":"page"},{"location":"bitsbase/#BitsX.BitsBase.bit","page":"BitsBase","title":"BitsX.BitsBase.bit","text":"bit(x::Real, i::Integer)\n\nSimilar to Bits.bit from registered Bits.jl package. A difference is that the return type here does not depend on the input type, but rather is always Int. (Check a. is this true and b. what do we prefer?)\n\n\n\n\n\nbit(str::AbstractString, i::Integer)::Int\n\nReturn 1 if the ith character of str is '1' and 0 if it is '0'. Otherwise throw an ArgumentError.\n\nIt is assumed that str has one byte per character, or more precisely, one UInt8 code unit per code point. Thus, accessing the ith character via bit may be more efficient than str[i].\n\n\n\n\n\n","category":"function"},{"location":"bitsbase/#tstbit","page":"BitsBase","title":"tstbit","text":"","category":"section"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"tstbit","category":"page"},{"location":"bitsbase/#BitsX.BitsBase.tstbit","page":"BitsBase","title":"BitsX.BitsBase.tstbit","text":"tstbit(x::Real, i::Integer) -> Bool\n\nSimilar to bit but returns the bit at position i as a Bool.\n\nExamples\n\njulia> tstbit(0b101, 3)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"bitsbase/#bit0","page":"BitsBase","title":"bit0","text":"","category":"section"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"bit0","category":"page"},{"location":"bitsbase/#BitsX.BitsBase.bit0","page":"BitsBase","title":"BitsX.BitsBase.bit0","text":"bit0(x, i)\n\nLike bit(x, i) except the first bit has index 0 rather than 1.\n\n\n\n\n\n","category":"function"},{"location":"bitsbase/#tstbit0","page":"BitsBase","title":"tstbit0","text":"","category":"section"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"tstbit0","category":"page"},{"location":"bitsbase/#BitsX.BitsBase.tstbit0","page":"BitsBase","title":"BitsX.BitsBase.tstbit0","text":"tstbit0(x, i)\n\nLike tstbit(x, i) except the first bit has index 0 rather than 1.\n\n\n\n\n\n","category":"function"},{"location":"bitsbase/#ZeroBased","page":"BitsBase","title":"ZeroBased","text":"","category":"section"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"ZeroBased","category":"page"},{"location":"bitsbase/#BitsX.BitsBase.ZeroBased","page":"BitsBase","title":"BitsX.BitsBase.ZeroBased","text":"struct OneBased\n\nA type used for dispatch that signifies that the first index is zero.\n\n\n\n\n\n","category":"type"},{"location":"bitsbase/#OneBased","page":"BitsBase","title":"OneBased","text":"","category":"section"},{"location":"bitsbase/","page":"BitsBase","title":"BitsBase","text":"OneBased","category":"page"},{"location":"bitsbase/#BitsX.BitsBase.OneBased","page":"BitsBase","title":"BitsX.BitsBase.OneBased","text":"struct OneBased\n\nA type used for dispatch that signifies that the first index is one.\n\n\n\n\n\n","category":"type"},{"location":"bitarrays/","page":"BitArrays","title":"BitArrays","text":"CurrentModule = BitsX.BitArrays","category":"page"},{"location":"bitarrays/","page":"BitArrays","title":"BitArrays","text":"Pages = [\"bitarrays.md\"]","category":"page"},{"location":"bitarrays/","page":"BitArrays","title":"BitArrays","text":"Modules = [BitArrays]","category":"page"},{"location":"bitarrays/#BitsX.BitArrays","page":"BitArrays","title":"BitsX.BitArrays","text":"BitArrays\n\nThis module implements a few functions for constructing Base.BitArray objects.\n\n\n\n\n\n","category":"module"},{"location":"bitarrays/#BitsX.BitArrays.bitarray!-Tuple{AbstractVector{UInt64}, Tuple}","page":"BitArrays","title":"BitsX.BitArrays.bitarray!","text":"bitarray!(vector::AbstractVector{<:Unsigned}, [dims]) where {T}\n\nReturn a BitArray with dimensions dims using vector as chunks.\n\nIf vector is not a Vector, it will be copied. If vector is a Vector{T} then it will be reinterpreted to T  == UInt64 after possible padding.\n\nExamples\n\njulia> (bitarray!([UInt8(1), UInt8(2)]),)\n(Bool[1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],)\n\n\n\n\n\n","category":"method"},{"location":"bitarrays/#BitsX.BitArrays.bitarray-Tuple{Union{Float16, Float32, Float64, Integer}, Vararg{Int64}}","page":"BitArrays","title":"BitsX.BitArrays.bitarray","text":"bitarray(x::Union{Integer, Base.IEEEFloat}, [dims])\n\nReturn a BitArray from the bits in x.\n\nExamples\n\njulia> (bitarray(typemax(UInt16)),)\n(Bool[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],)\n\njulia> bitarray(typemax(UInt16), (2, 8))\n2×8 BitMatrix:\n 1  1  1  1  1  1  1  1\n 1  1  1  1  1  1  1  1\n\n\n\n\n\n","category":"method"},{"location":"bitarrays/#BitsX.BitArrays.bitvector-Tuple{Union{Float16, Float32, Float64, Integer}}","page":"BitArrays","title":"BitsX.BitArrays.bitvector","text":"bitvector(x::Union{Integer, Base.IEEEFloat})\n\nReturn a BitVector with the bits in x.\n\nExamples\n\njulia> (bitvector(UInt8(11)), )\n(Bool[1, 1, 0, 1, 0, 0, 0, 0],)\n\njulia> bstring(bitvector(UInt64(1<<32 -1)))\n\"1111111111111111111111111111111100000000000000000000000000000000\"\n\njulia> typeof(bitvector(UInt64(1<<32 -1)))\nBitVector (alias for BitArray{1})\n\n\n\n\n\n","category":"method"},{"location":"#BitsX.jl","page":"Introduction","title":"BitsX.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"DocTestSetup = quote\n    using BitsX\nend","category":"page"},{"location":"#BitsX","page":"Introduction","title":"BitsX","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"BitsX","category":"page"},{"location":"#BitsX","page":"Introduction","title":"BitsX","text":"module BitsX\n\nBitsX is a collection of types and functions for working with representations bits.\n\nA main idea is to have a convenient, performant, and uniform interface to working with representations of bits in various data types. For example a vector of bits may be represented as a value of any of Vector{Bool}, UInt64, String, etc. The abstractions supporting this idea are in BitsBase (for the most part).\n\nVocabulary\n\nbit string:  an AbstractString whose characters are all '1' and '0'. In some contexts, formatting  characters may be present as well.\n\nwarn: Warn\nThe API of BitsX is large, perhapse too large. Much of it is rather exploratory and incomplete. In particular, interfaces for types that require a lot of implemenation are incomplete.BitsX.jl has recently been reorganized and modularized. It might be a good idea to split it into  smaller packages.\n\nRelated packages\n\nBitBasis.jl\nBitFlags.jl\nBitInformation.jl\nBitIntegers.jl\nBitOperations.jl\nBitPermutations.jl\nBits.jl\nFieldFlags.jl\nBitTwiddlingConvenienceFunctions\nBitConverter.jl\nBitVectorExtensions.jl\nBitMasks.jl\nFlagSets.jl\nBitsFields.jl\nBitSetTuples.jl\nBitFloats.jl\n\n\n\n\n\n","category":"module"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"index.md\", \"bitsbase.md\", \"bitstrings.md\", \"bits.md\", \"misc.md\"]\nDepth = 5","category":"page"},{"location":"#Index","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"bits/","page":"Masks and miscellany","title":"Masks and miscellany","text":"CurrentModule = BitsX.Bits","category":"page"},{"location":"bits/#Contents","page":"Masks and miscellany","title":"Contents","text":"","category":"section"},{"location":"bits/","page":"Masks and miscellany","title":"Masks and miscellany","text":"Pages = [\"bits.md\"]\nDepth = 5","category":"page"},{"location":"bits/#Masking","page":"Masks and miscellany","title":"Masking","text":"","category":"section"},{"location":"bits/#mask","page":"Masks and miscellany","title":"mask","text":"","category":"section"},{"location":"bits/","page":"Masks and miscellany","title":"Masks and miscellany","text":"mask","category":"page"},{"location":"bits/#BitsX.Bits.mask","page":"Masks and miscellany","title":"BitsX.Bits.mask","text":"mask([T=UInt], i::Integer)\nmask([T=UInt], r::UnitRange)\nmask([T=UInt], itr)\n\nReturn n::T with the specified bits set to one and the rest zero. The bits specified by each item in itr will be set to one. Overlaps between ranges will have their bits set to one.\n\nSee leftmask, rightmask, rangemask.\n\nExamples\n\njulia> bitstring(mask(UInt8, 3))\n\"00000100\"\n\njulia> bitstring(mask(UInt8, (1, 5, 8)))\n\"10010001\"\n\njulia> bitstring(mask(UInt8, (2, 5, 8)))\n\"10010010\"\n\njulia> bitstring(mask(1:2:64))\n\"0101010101010101010101010101010101010101010101010101010101010101\"\n\njulia> bitstring(mask(UInt16, (1:3, 9, 14:16)))\n\"1110000100000111\"\n\n\n\n\n\n","category":"function"},{"location":"bits/#masked","page":"Masks and miscellany","title":"masked","text":"","category":"section"},{"location":"bits/","page":"Masks and miscellany","title":"Masks and miscellany","text":"masked","category":"page"},{"location":"bits/#BitsX.Bits.masked","page":"Masks and miscellany","title":"BitsX.Bits.masked","text":"masked([ib::IndexBase], x::T, inds...) where {T}\n\nReturn the result of applying the mask determined by inds to x.\n\nThat is, return x & mask(T, inds...)\n\nExamples\n\njulia> masked(0b11110011, 1:5) === 0b00010011\ntrue\n\njulia> x = rand(); masked(-x, 1:63) === x\ntrue\n\n\n\n\n\n","category":"function"},{"location":"bits/#rightmask","page":"Masks and miscellany","title":"rightmask","text":"","category":"section"},{"location":"bits/","page":"Masks and miscellany","title":"Masks and miscellany","text":"rightmask","category":"page"},{"location":"bits/#BitsX.Bits.rightmask","page":"Masks and miscellany","title":"BitsX.Bits.rightmask","text":"rightmask([T=UInt], i)\n\nReturn n::T such that the ith bit and all bits to the right (lower) are one, and all bits to the left of the ith bit (higher) are zero.\n\nSee also leftmask, rangemask, mask.\n\nExamples\n\njulia> bitstring(rightmask(UInt8, 3))\n\"00000111\"\n\n\n\n\n\n","category":"function"},{"location":"bits/#leftmask","page":"Masks and miscellany","title":"leftmask","text":"","category":"section"},{"location":"bits/","page":"Masks and miscellany","title":"Masks and miscellany","text":"leftmask","category":"page"},{"location":"bits/#BitsX.Bits.leftmask","page":"Masks and miscellany","title":"BitsX.Bits.leftmask","text":"leftmask([T=UInt], i)\n\nReturn n::T such that the ith bit and all bits to the left (higher) are one, and all bits to the right of the ith bit (lower) are zero.\n\nSee rightmask, rangemask, mask.\n\nExamples\n\njulia> bitstring(leftmask(UInt8, 3))\n\"11111100\"\n\n\n\n\n\n","category":"function"},{"location":"bits/#rangemask","page":"Masks and miscellany","title":"rangemask","text":"","category":"section"},{"location":"bits/","page":"Masks and miscellany","title":"Masks and miscellany","text":"rangemask","category":"page"},{"location":"bits/#BitsX.Bits.rangemask","page":"Masks and miscellany","title":"BitsX.Bits.rangemask","text":"rangemask([T=UInt], ilo, ihi)\nrangemask([T=UInt], (ilo, ihi)...)\n\nReturn n::T such that all bits in the range ilo to ihi, inclusive, are one, and all other bits are zero. If Tuples (ilo, ihi)... are given, then set bits in each range to one.\n\nSee leftmask, rightmask, mask.\n\nExamples\n\njulia> bitstring(rangemask(UInt8, 2, 7))\n\"01111110\"\n\njulia> bitstring(rangemask(UInt16, (1, 3), (5, 8), (14, 16)))\n\"1110000011110111\"\n\njulia> bitstring(rangemask(UInt8, (1, 5), (4, 8)))\n\"11111111\"\n\n\n\n\n\n","category":"function"},{"location":"bits/#Miscellany","page":"Masks and miscellany","title":"Miscellany","text":"","category":"section"},{"location":"bits/#undigits","page":"Masks and miscellany","title":"undigits","text":"","category":"section"},{"location":"bits/","page":"Masks and miscellany","title":"Masks and miscellany","text":"undigits","category":"page"},{"location":"bits/#BitsX.Bits.undigits","page":"Masks and miscellany","title":"BitsX.Bits.undigits","text":"undigits([IntT=Int], A; base=10, rev=false)::IntT\n\nThe inverse of digits. That is undigits(digits(n; base); base) == n. The number returned is of type IntT provided that the type is stable under + and *, and that each element of A can be converted to IntT.\n\nExceptions\n\nOverflowError if A represents a number larger than typemax(IntT). For  Unsigned types the check is more strict in that length(A) must not be   greater than the number of bits in IntT, even if there are leading zeros.\n\nExamples\n\njulia> undigits([2, 4])\n42\n\njulia> undigits([2, 4]; rev=true)\n24\n\njulia> undigits(UInt8, [1, 0, 1, 1]; base=2) 0x0d\n\njulia> bstring(undigits(UInt8, [1, 0, 1, 1]; base=2); pad=true) \"1011\"\n\n\n\n\n\n","category":"function"},{"location":"bits/#bitcollect","page":"Masks and miscellany","title":"bitcollect","text":"","category":"section"},{"location":"bits/","page":"Masks and miscellany","title":"Masks and miscellany","text":"bitcollect","category":"page"},{"location":"bits/#BitsX.Bits.bitcollect","page":"Masks and miscellany","title":"BitsX.Bits.bitcollect","text":"bitcollect(obj)\n\nConvert the representation of a bit array obj to an Array{Bool}.\n\n\n\n\n\n","category":"function"},{"location":"bits/#bit_count_ones","page":"Masks and miscellany","title":"bit_count_ones","text":"","category":"section"},{"location":"bits/","page":"Masks and miscellany","title":"Masks and miscellany","text":"bit_count_ones","category":"page"},{"location":"bits/#BitsX.Bits.bit_count_ones","page":"Masks and miscellany","title":"BitsX.Bits.bit_count_ones","text":"bit_count_ones(v)\n\nCount the number of bit values in v equal to one.\n\n\n\n\n\nbit_count_ones(s::AbstractString)\n\nCount the number of characters in s equal to '1'.\n\n\n\n\n\n","category":"function"},{"location":"bits/#bit_count_zeros","page":"Masks and miscellany","title":"bit_count_zeros","text":"","category":"section"},{"location":"bits/","page":"Masks and miscellany","title":"Masks and miscellany","text":"bit_count_zeros","category":"page"},{"location":"bits/#BitsX.Bits.bit_count_zeros","page":"Masks and miscellany","title":"BitsX.Bits.bit_count_zeros","text":"bit_count_zeros(v)\n\nCount the number of bit values in v equal to one.\n\n\n\n\n\nbit_count_zeros(s::AbstractString)\n\nCount the number of characters in s equal to '0'.\n\n\n\n\n\n","category":"function"},{"location":"bits/#BitStringArray","page":"Masks and miscellany","title":"BitStringArray","text":"","category":"section"},{"location":"bits/","page":"Masks and miscellany","title":"Masks and miscellany","text":"BitStringArray has essential things implemented. Documentation is incomplete.","category":"page"},{"location":"bits/","page":"Masks and miscellany","title":"Masks and miscellany","text":"BitStringArray","category":"page"},{"location":"bits/#BitsX.Bits.BitStringArray","page":"Masks and miscellany","title":"BitsX.Bits.BitStringArray","text":"BitStringArray{T <: AbstractVector{<:AbstractString}, N} <: AbstractArray{Bool, N}\n\nAn array of Bools represented by a vector of bitstrings.\n\n\n\n\n\n","category":"type"}]
}
